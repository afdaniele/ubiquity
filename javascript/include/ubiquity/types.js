// Generated by CoffeeScript 2.5.1
(function() {
  var DEFAULT_TIMEOUT_SECS, Field, ITERABLE_TYPES, Logger, Method, PRIMITIVE_TYPES, Parameter, ParameterType, Quantum, QuantumStub, ShoeboxContent, ShoeboxIF, TunnelIF, WaveIF, uuid4;

  uuid4 = require('uuid4');

  DEFAULT_TIMEOUT_SECS = 10;

  PRIMITIVE_TYPES = [number, String, null];

  ITERABLE_TYPES = [Array, Set];

  Logger = class Logger {
    constructor(name) {
      this._name = name;
    }

    _log(type, message) {
      return console.log(`${type}:${message}`);
    }

    info(message) {
      return this._log('INFO', message);
    }

    warn(message) {
      return this._log('WARN', message);
    }

    error(message) {
      return this._log('ERROR', message);
    }

  };

  ShoeboxContent = class ShoeboxContent {
    constructor() {}

  };

  QuantumStub = class QuantumStub {
    constructor() {}

  };

  ParameterType = (function() {
    var DEFAULT, KEYWORD, POSITIONAL, VAR_KEYWORD, VAR_POSITIONAL;

    class ParameterType {
      from_inspect_type(itype) {
        // TODO: Likely this is useless
        return null;
      }

    };

    // NOTE: This has to match the PB protocol
    DEFAULT = 0;

    POSITIONAL = 1;

    KEYWORD = 2;

    VAR_POSITIONAL = 3;

    VAR_KEYWORD = 4;

    return ParameterType;

  }).call(this);

  ShoeboxIF = class ShoeboxIF {
    constructor(name) {
      this._name = name;
      this._quanta = {};
      this._tunnels = {};
      this._objects = {};
      this._waves_in = {};
      this.__logger__ = new Logger(this.toString());
      //    TODO: semaphore here
      this._waves_in_lock = null;
      self._content = new ShoeboxContent();
      Object.defineProperties(this.prototype, {
        name: {
          get: function() {
            return this._name;
          }
        },
        quanta: {
          get: function() {
            return this._quanta;
          }
        },
        objects: {
          get: function() {
            return this._objects;
          }
        },
        content: {
          get: function() {
            return this._content;
          }
        },
        logger: {
          get: function() {
            return this.__logger__;
          }
        }
      });
    }

    register_quantum(obj/*: any */, quantum_id/*: null | number */ = null)/*: number */ {
      throw "NotImplementedError";
    }

    name_quantum(name/*: str */, quantum_id/*: number */) {
      throw "NotImplementedError";
    }

    add(name/*: str */, obj/*: any */) {
      throw "NotImplementedError";
    }

    attach(tunnel/*: TunnelIF */) {
      throw "NotImplementedError";
    }

    detach(tunnel/*: TunnelIF */) {
      throw "NotImplementedError";
    }

    wave_in(wave/*: WaveIF */) {
      throw "NotImplementedError";
    }

    wave_out(wave/*: WaveIF */) {
      throw "NotImplementedError";
    }

    wait_on(request_wave/*: string | WaveIF */, timeout/*: number */ = -1) {
      throw "NotImplementedError";
    }

    destroy() {
      throw "NotImplementedError";
    }

    serialize()/*: ShoeboxPB */ {
      throw "NotImplementedError";
    }

    deserialize(shoebox_pb/*: ShoeboxPB */)/*: ShoeboxIF */ {
      throw "NotImplementedError";
    }

    toString()/*: string */ {
      return `SB[${this.name}]`;
    }

    __str__()/*: string */ {
      return this.toString();
    }

  };

  TunnelIF = class TunnelIF {
    constructor() {
      this._shoebox = null;
      this._is_shutdown = false;
      this.__logger__ = null;
      Object.defineProperties(this.prototype, {
        shoebox: {
          get: function() {
            return this._shoebox;
          }
        },
        is_shutdown: {
          get: function() {
            return this._is_shutdown;
          }
        },
        logger: {
          get: function() {
            if (this.__logger__ === null) {
              this.__logger__ = new Logger(`TN\\${this.toString()}/`);
            }
            return this.__logger__;
          }
        }
      });
    }

    start() {
      throw "NotImplementedError";
    }

    shutdown() {
      return this._is_shutdown = true;
    }

    attach(shoebox/*: ShoeboxIF */) {
      throw "NotImplementedError";
    }

    detach() {
      throw "NotImplementedError";
    }

    wave_in(wave_raw/*: string */)/*: Union[WaveIF, null] */ {
      throw "NotImplementedError";
    }

    wave_out(wave/*: WaveIF */) {
      throw "NotImplementedError";
    }

    _send_wave(wave_raw/*: string */) {
      throw "NotImplementedError";
    }

    toString()/*: string */ {
      throw "NotImplementedError";
    }

    __str__()/*: string */ {
      return this.toString();
    }

  };

  WaveIF = (function() {
    var _type;

    class WaveIF {
      constructor(shoebox/*: Union[ShoeboxIF, null] */, quantum_id/*: Union[QuantumID, null] */, request_wave/*: Union[string, null] */, wave_id/*: Union[string, null] */ = null) {
        if (wave_id === null) {
          this._id = uuid4();
        } else {
          this._id = wave_id;
        }
        this._shoebox = shoebox;
        this._quantum_id = quantum_id;
        this._request_wave = request_wave;
        this.__logger__ = new Logger(this.toString());
        Object.defineProperties(this.prototype, {
          id: {
            get: function()/*: Union[string, null] */ {
              return this._id;
            }
          },
          shoebox: {
            get: function()/*: Union[ShoeboxIF, null] */ {
              return this._shoebox;
            }
          },
          quantum_id: {
            get: function()/*: Union[QuantumID, null] */ {
              return this._quantum_id;
            }
          },
          request_wave: {
            get: function()/*: Union[string, null] */ {
              return this._request_wave;
            }
          },
          logger: {
            get: function()/*: Union[string, null] */ {
              return this.__logger__;
            }
          }
        });
      }

      hit(shoebox/*: Union[ShoeboxIF, null] */)/*: Union[WaveIF, null] */ {
        throw "NotImplementedError";
      }

      _serialize()/*: Any */ {
        throw "NotImplementedError";
      }

      deserialize(wave_pb/*: Any */)/*: WaveIF */ {
        throw "NotImplementedError";
      }

      serialize()/*: WavePB */ {
        throw "NotImplementedError";
      }

      serialize_data()/*: Any */ {
        throw "NotImplementedError";
      }

      toString()/*: string */ {
        return `WV{${this._id.slice(0, 8)}}${this._type}`;
      }

      __str__()/*: string */ {
        return this.toString();
      }

    };

    _type = "**";

    return WaveIF;

  }).call(this);

  Field = class Field {
    constructor(name/*: string */, ftype/*: FieldType */) {
      this._name = name;
      this._type = type;
      Object.defineProperties(this.prototype, {
        name: {
          get: function()/*: Union[string, null] */ {
            return this._name;
          }
        },
        type: {
          get: function()/*: Union[ShoeboxIF, null] */ {
            return this._type;
          }
        }
      });
    }

    serialize()/*: FieldPB */ {
      return proto.FieldPB().setName(this._name).setType(this._type.toString());
    }

  };

  Parameter = class Parameter {
    constructor(name/*: string */, ptype/*: ParameterType */, annotation/*: Any */, default_value/*: Any */) {
      this._name = name;
      this._type = ptype;
      this._annotation = annotation;
      this._default_value = default_value;
      Object.defineProperties(this.prototype, {
        name: {
          get: function()/*: string */ {
            return this._name;
          }
        },
        type: {
          get: function()/*: ParameterType */ {
            return this._type;
          }
        },
        annotation: {
          get: function()/*: Any */ {
            return this._annotation;
          }
        },
        default: {
          get: function()/*: Any */ {
            return this._default_value;
          }
        }
      });
    }

    serialize()/*: FieldPB */ {
      return proto.ParameterPB().setName(this._name).setType(this._type).setAnnotation(this._annotation);
    }

  };

  Method = class Method {
    constructor(name/*: string */, args/*: Iterable[Parameter] */) {
      this._name = name;
      this._args = args;
      Object.defineProperties(this.prototype, {
        name: {
          get: function()/*: string */ {
            return this._name;
          }
        },
        args: {
          get: function()/*: Iterable[Parameter] */ {
            return this._args;
          }
        }
      });
    }

    serialize()/*: MethodPB */ {
      var _s, p;
      _s = function(p) {
        return p.serialize();
      };
      return proto.MethodPB().setName(this._name).setArgs((function() {
        var i, len, ref, results;
        ref = this._args;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          p = ref[i];
          results.push(_s(p));
        }
        return results;
      }).call(this));
    }

  };

  Quantum = class Quantum {
    constructor(quantum_id/*: QuantumID */) {
      this._id = quantum_id;
      this._fields = [];
      this._methods = [];
      this.__logger__ = new Logger(this.toString());
      Object.defineProperties(this.prototype, {
        id: {
          get: function()/*: QuantumID */ {
            return this._id;
          }
        },
        fields: {
          get: function()/*: Iterable[Field] */ {
            return this._fields;
          }
        },
        methods: {
          get: function()/*: Iterable[Method] */ {
            return this._methods;
          }
        },
        logger: {
          get: function()/*: Logger */ {
            return this._logger;
          }
        }
      });
    }

    add_field(field/*: Field */) {
      return this._fields.push(field);
    }

    add_method(method/*: Method */) {
      return this._methods.push(method);
    }

    serialize()/*: MethodPB */ {
      var _f, _m, field, method;
      _f = function(f) {
        return f.serialize();
      };
      _m = function(m) {
        return m.serialize();
      };
      return proto.QuantumPB().setId(this._id).setFieldsList((function() {
        var i, len, ref, results;
        ref = this._fields;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          field = ref[i];
          results.push(_f(field));
        }
        return results;
      }).call(this)).setMethodsList((function() {
        var i, len, ref, results;
        ref = this._methods;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          method = ref[i];
          results.push(_m(method));
        }
        return results;
      }).call(this));
    }

    deserialize(quantum_pb/*: QuantumPB */)/*: Quantum */ {
      var field, i, j, len, len1, method, p, quantum, ref, ref1;
      quantum = Quantum(quantum_pb.getId());
      ref = quantum_pb.getFieldsList();
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        quantum.add_field(Field(field.getName(), field.getType()));
      }
      ref1 = quantum_pb.getMethodsList();
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        method = ref1[j];
        quantum.add_method(Method(method.getName(), (function() {
          var k, len2, ref2, results;
          ref2 = method.getArgsList();
          results = [];
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            p = ref2[k];
            results.push(Parameter(p.getName(), ParameterType(p.getType()), p.getAnnotation(), deserialize_any(p.getDefaultValue())));
          }
          return results;
        })()));
      }
      return quantum;
    }

    toString()/*: string */ {
      return `QT+{${this._id}}`;
    }

    __str__()/*: string */ {
      return this.toString();
    }

    from_object(obj/*: Any */, quantum_id/*: QuantumID */)/*: Tuple[QuantumID, Quantum] */ {
      var stub;
      // base case: already a quantum
      if (obj instanceof Quantum) {
        return [obj.id, obj];
      }
      // base case: quantumStubs are for local use only, cannot turn it back into a quantum
      if (obj instanceof QuantumStub) {
        throw 'Objects of type QuantumStub cannot be turned back into a Quantum';
      }
      // if the ID is not given, a new one will be assigned
      // TODO: fix this as there is no id() function in JS
      if (quantum_id === null) {
        quantum_id = 0;
      }
      // create stub for the object
      stub = Quantum(quantum_id);
      // add fields to stub
      // TODO: find something similar to gemembers()
      // add methods to stub
      // TODO: find something similar to gemembers()
      // ---
      return [quantum_id, stub];
    }

    to_stub(destination/*: ShoeboxIF */)/*: QuantumStub */ {
      // TODO: find something similar to property()
      return 0;
    }

    build_stubs(obj/*: Any */, shoebox/*: ShoeboxIF */)/*: Any */ {
      var e, i, j, len, len1, type;
// primitives
      for (i = 0, len = PRIMITIVE_TYPES.length; i < len; i++) {
        type = PRIMITIVE_TYPES[i];
        if (obj instanceof type) {
          return obj;
        }
      }
// iterables
      for (j = 0, len1 = ITERABLE_TYPES.length; j < len1; j++) {
        type = ITERABLE_TYPES[j];
        if (obj instanceof type) {
          return (function() {
            var k, len2, results;
            results = [];
            for (k = 0, len2 = obj.length; k < len2; k++) {
              e = obj[k];
              results.push(Quantum.build_stubs(e, shoebox));
            }
            return results;
          })();
        }
      }
      // Quantum
      if (obj instanceof Quantum) {
        return obj.to_stub(shoebox);
      }
      // ---
      throw `Cannot build Stub for object of type {${typeof obj}}`;
    }

  };

}).call(this);
